import { Inject, Injectable } from '@nestjs/common';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';

import {
  CreateSeatingFloorDto,
  CreateSeatingLayoutRequestDto,
  CreateSeatingLayoutSectionDto,
  CreateSeatingResourceDto,
  SeatingFloor,
  SeatingLayout,
  SeatingLayoutSection,
  SeatingResource,
  UpdateSeatingFloorDto,
  UpdateSeatingLayoutRequestDto,
  UpdateSeatingLayoutSectionDto,
  UpdateSeatingResourceDto,
  UpsertSeatingFloorDto,
  UpsertSeatingResourceDto,
  UpsertSeatingSectionDto,
} from '@wcp/wario-shared';

import { SocketIoService } from 'src/infrastructure/messaging/socket-io/socket-io.service';
import { DataProviderService } from 'src/modules/data-provider/data-provider.service';
import {
  SEATING_FLOOR_REPOSITORY,
  SEATING_LAYOUT_REPOSITORY,
  SEATING_RESOURCE_REPOSITORY,
  SEATING_SECTION_REPOSITORY,
} from 'src/repositories/interfaces';
import type { ISeatingFloorRepository } from 'src/repositories/interfaces/seating-floor.repository.interface';
import type { ISeatingLayoutRepository } from 'src/repositories/interfaces/seating-layout.repository.interface';
import type { ISeatingResourceRepository } from 'src/repositories/interfaces/seating-resource.repository.interface';
import type { ISeatingSectionRepository } from 'src/repositories/interfaces/seating-section.repository.interface';

@Injectable()
export class SeatingService {
  constructor(
    @Inject(SEATING_FLOOR_REPOSITORY)
    private readonly seatingFloorRepository: ISeatingFloorRepository,
    @Inject(SEATING_LAYOUT_REPOSITORY)
    private readonly seatingLayoutRepository: ISeatingLayoutRepository,
    @Inject(SEATING_RESOURCE_REPOSITORY)
    private readonly seatingResourceRepository: ISeatingResourceRepository,
    @Inject(SEATING_SECTION_REPOSITORY)
    private readonly seatingSectionRepository: ISeatingSectionRepository,
    private readonly socketIoService: SocketIoService,
    private readonly dataProvider: DataProviderService,
    @InjectPinoLogger(SeatingService.name)
    private readonly logger: PinoLogger,
  ) {}

  // --- FLOORS ---

  async getAllFloors(): Promise<SeatingFloor[]> {
    return this.seatingFloorRepository.findAll();
  }

  async getFloor(id: string): Promise<SeatingFloor | null> {
    return this.seatingFloorRepository.findById(id);
  }

  async createFloor(floor: Omit<SeatingFloor, 'id'>): Promise<SeatingFloor> {
    const created = await this.seatingFloorRepository.create(floor);
    return created;
  }

  async updateFloor(id: string, update: Partial<Omit<SeatingFloor, 'id'>>): Promise<SeatingFloor | null> {
    const updated = await this.seatingFloorRepository.update(id, update);
    return updated;
  }

  async deleteFloor(id: string): Promise<boolean> {
    return this.seatingFloorRepository.delete(id);
  }

  // --- LAYOUTS ---

  async getAllLayouts(): Promise<Omit<SeatingLayout, 'floors' | 'sections' | 'resources'>[]> {
    return this.seatingLayoutRepository.findAll();
  }

  async getLayout(id: string): Promise<SeatingLayout | null> {
    return this.seatingLayoutRepository.findById(id);
  }

  async createLayout(layout: CreateSeatingLayoutRequestDto): Promise<SeatingLayout> {
    // 1. Create the layout entity first (only name, id is generated by DB)
    const createdLayout = await this.seatingLayoutRepository.create({ name: layout.name });

    // 2. Create floors and build ID mapping (client ID -> server ID)
    const floorIdMap = new Map<string, string>();
    const createdFloors: SeatingFloor[] = [];

    for (const floor of layout.floors) {
      const { id: _clientId, ...floorData } = floor;
      const createdFloor = await this.seatingFloorRepository.create(floorData);
      floorIdMap.set(floor.id, createdFloor.id);
      createdFloors.push(createdFloor);
    }

    // 3. Create sections with mapped floorIds
    const sectionIdMap = new Map<string, string>();
    const createdSections: SeatingLayoutSection[] = [];

    for (const section of layout.sections) {
      const { id: _clientId, ...sectionData } = section;
      const mappedFloorId = floorIdMap.get(section.floorId) ?? section.floorId;
      const createdSection = await this.seatingSectionRepository.create({
        ...sectionData,
        floorId: mappedFloorId,
      });
      sectionIdMap.set(section.id, createdSection.id);
      createdSections.push(createdSection);
    }

    // 4. Create resources with mapped sectionIds (resources now include position/rotation)
    const createdResources: SeatingResource[] = [];

    for (const resource of layout.resources) {
      const { id: _clientId, ...resourceData } = resource;
      const mappedSectionId = sectionIdMap.get(resource.sectionId) ?? resource.sectionId;
      const createdResource = await this.seatingResourceRepository.create({
        ...resourceData,
        sectionId: mappedSectionId,
      });
      createdResources.push(createdResource);
    }

    return {
      id: createdLayout.id,
      name: createdLayout.name,
      floors: createdFloors,
      sections: createdSections,
      resources: createdResources,
    };
  }

  async updateLayout(id: string, layout: UpdateSeatingLayoutRequestDto): Promise<SeatingLayout | null> {
    // 1. Check if layout exists
    const existingLayout = await this.seatingLayoutRepository.findById(id);
    if (!existingLayout) return null;

    // Update layout name if provided
    if (layout.name !== undefined) {
      await this.seatingLayoutRepository.update(id, { name: layout.name });
    }

    // Sync nested entities if provided
    if (layout.floors) {
      await this.syncFloors(existingLayout.floors, layout.floors);
    }

    if (layout.sections) {
      await this.syncSections(existingLayout.sections, layout.sections);
    }

    if (layout.resources) {
      await this.syncResources(existingLayout.resources, layout.resources);
    }

    return this.getLayout(id);
  }

  /**
   * Sync floors: entities with id = update, entities without id = create, missing = delete
   */
  private async syncFloors(existing: SeatingFloor[], incoming: UpsertSeatingFloorDto[]): Promise<void> {
    const existingIds = new Set(existing.map((f) => f.id));

    // Separate by presence of id
    const toCreate = incoming.filter((f): f is CreateSeatingFloorDto => !('id' in f));
    const toUpdate = incoming.filter((f): f is UpdateSeatingFloorDto => 'id' in f);
    const incomingIds = new Set(toUpdate.map((f) => f.id));

    // Create new floors
    for (const floor of toCreate) {
      await this.seatingFloorRepository.create(floor);
    }

    // Update existing floors
    for (const floor of toUpdate) {
      if (existingIds.has(floor.id)) {
        const { id, ...data } = floor;
        await this.seatingFloorRepository.update(id, data);
      } else {
        this.logger.warn({ floorId: floor.id }, 'Floor with ID not found for update, skipping');
      }
    }

    // Delete floors not in incoming (cascade to sections, resources)
    for (const floor of existing) {
      if (!incomingIds.has(floor.id)) {
        const sections = await this.seatingSectionRepository.findByFloorId(floor.id);
        for (const section of sections) {
          await this.cascadeDeleteSection(section.id);
        }
        await this.seatingFloorRepository.delete(floor.id);
      }
    }
  }

  /**
   * Sync sections: entities with id = update, entities without id = create, missing = delete
   */
  private async syncSections(existing: SeatingLayoutSection[], incoming: UpsertSeatingSectionDto[]): Promise<void> {
    const existingIds = new Set(existing.map((s) => s.id));

    // Separate by presence of id
    const toCreate = incoming.filter((s): s is CreateSeatingLayoutSectionDto => !('id' in s));
    const toUpdate = incoming.filter((s): s is UpdateSeatingLayoutSectionDto => 'id' in s);
    const incomingIds = new Set(toUpdate.map((s) => s.id));

    // Create new sections
    for (const section of toCreate) {
      await this.seatingSectionRepository.create(section);
    }

    // Update existing sections
    for (const section of toUpdate) {
      if (existingIds.has(section.id)) {
        const { id, ...data } = section;
        await this.seatingSectionRepository.update(id, data);
      } else {
        this.logger.warn({ sectionId: section.id }, 'Section with ID not found for update, skipping');
      }
    }

    // Delete sections not in incoming (cascade)
    for (const section of existing) {
      if (!incomingIds.has(section.id)) {
        await this.cascadeDeleteSection(section.id);
      }
    }
  }

  /**
   * Cascade delete a section and its resources
   */
  private async cascadeDeleteSection(sectionId: string): Promise<void> {
    const resources = await this.seatingResourceRepository.findBySectionId(sectionId);
    for (const resource of resources) {
      await this.seatingResourceRepository.delete(resource.id);
    }

    await this.seatingSectionRepository.delete(sectionId);
  }

  /**
   * Sync resources: entities with id = update, entities without id = create, missing = delete
   */
  private async syncResources(existing: SeatingResource[], incoming: UpsertSeatingResourceDto[]): Promise<void> {
    const existingIds = new Set(existing.map((r) => r.id));

    // Separate by presence of id
    const toCreate = incoming.filter((r): r is CreateSeatingResourceDto => !('id' in r));
    const toUpdate = incoming.filter((r): r is UpdateSeatingResourceDto => 'id' in r);
    const incomingIds = new Set(toUpdate.map((r) => r.id));

    // Create new resources
    for (const resource of toCreate) {
      await this.seatingResourceRepository.create(resource);
    }

    // Update existing resources
    for (const resource of toUpdate) {
      if (existingIds.has(resource.id)) {
        const { id, ...data } = resource;
        await this.seatingResourceRepository.update(id, data);
      } else {
        this.logger.warn({ resourceId: resource.id }, 'Resource with ID not found for update, skipping');
      }
    }

    // Delete resources not in incoming
    for (const resource of existing) {
      if (!incomingIds.has(resource.id)) {
        await this.seatingResourceRepository.delete(resource.id);
      }
    }
  }

  async deleteLayout(id: string): Promise<boolean> {
    return this.seatingLayoutRepository.delete(id);
  }

  // --- SECTIONS ---

  async getAllSections(): Promise<SeatingLayoutSection[]> {
    return this.seatingSectionRepository.findAll();
  }

  async getSection(id: string): Promise<SeatingLayoutSection | null> {
    return this.seatingSectionRepository.findById(id);
  }

  async createSection(section: Omit<SeatingLayoutSection, 'id'>): Promise<SeatingLayoutSection> {
    return this.seatingSectionRepository.create(section);
  }

  async updateSection(
    id: string,
    update: Partial<Omit<SeatingLayoutSection, 'id'>>,
  ): Promise<SeatingLayoutSection | null> {
    return this.seatingSectionRepository.update(id, update);
  }

  async deleteSection(id: string): Promise<boolean> {
    return this.seatingSectionRepository.delete(id);
  }

  // --- RESOURCES ---

  async createResource(resource: Omit<SeatingResource, 'id'>): Promise<SeatingResource> {
    const created = await this.dataProvider.setSeatingResource(resource);
    await this.notifyResourceChanges();
    return created;
  }

  async updateResource(id: string, update: Partial<Omit<SeatingResource, 'id'>>): Promise<SeatingResource | null> {
    const updated = await this.dataProvider.updateSeatingResource(id, update);
    await this.notifyResourceChanges();
    return updated;
  }

  async deleteResource(id: string): Promise<boolean> {
    const result = await this.dataProvider.deleteSeatingResource(id);
    await this.notifyResourceChanges();
    return result;
  }

  async getAllResources(): Promise<Record<string, SeatingResource>> {
    return Promise.resolve(this.dataProvider.getSeatingResources());
  }

  private async notifyResourceChanges() {
    await this.dataProvider.syncSeatingResources();
    this.socketIoService.EmitSeatingResourcesTo(this.socketIoService.server, this.dataProvider.getSeatingResources());
  }
}
